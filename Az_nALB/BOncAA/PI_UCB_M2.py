# -*- coding: utf-8 -*-
"""Multi_objective.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iaZZFU-4FD7kQ2b9wRzgWYr-HZ73q66U

# Workflow:
## Goal: Optimize (minimize) the ddG or REU value for a single ncaa incorporation
### Input Parameter: Sequence position, 3d coordinate position, Avoid coordinate positions
### Optimization function: Rosetta Mutate and Relax protocol
### Acquisition: Sequence position (distant on a 1D level), 3d coordinate position(distant on a 3D level), Avoidance positions (distance on a 3D level from binding), Surface exposure
"""

'''Imports'''
import warnings
warnings.filterwarnings("ignore")
import sys
import os
sys.path.append(os.path.abspath(os.path.join(os.getcwd(), '..')))
from rosetta import *
from pyrosetta import *
from pyrosetta.rosetta.protocols.interface import select_interface_residues
from RncAAM.mutationscoring import g_chillaxer
from RncAAM.example import Mutation_Wrapper
from prep import coordinates, find_binding_region, binding_coordinates, distance_to_region, get_coordiantes, get_surface_exposures
import torch
import numpy as np
path = '../Parameters'
init(f'-extra_res_path {path} -mute all -constant_seed');

"""# Input Preparations

"""

protein_path = '../BOncAA/nALBbound.pdb'
complexed = pose_from_file(protein_path)
target_chain_letter = 'A'
complexed = g_chillaxer(complexed, target_chain_letter)

'''Get the sequence (1D representation of the protein)'''
target = Pose()
target_chain = complexed.split_by_chain()[2]
target.assign(target_chain)

target_range = range(1, len(target.sequence())+1)
print(len(target_range))

cystine_free = []
for i in range(1, len(target_range) +1):
    residue = target.residue(i)
    if residue.name() == 'C' or residue.name() == 'CYS:disulfide':
        print(f'removed residue {i}')
        continue
    else:
        cystine_free.append(i)
target_range = cystine_free
print(get_surface_exposures(target, target_range))

'''Prep all BO Inputs / Search Domain'''
coords = coordinates(target)
binding_region, nonbinding_region =find_binding_region(complexed, target_chain_letter=target_chain_letter)
b_coordinates, nb_coordinates = binding_coordinates(complexed, binding_region)
#d_to_binding = distance_to_binding(b_coordinates, nb_coordinates)

"""# Bayesian Optimization

"""

def objective(complexed_pose, chain, position, ncaa, smiles, radius_relax = 7,
              trials = 3, mutationrelx = True, mutation_dump = True):
    return(Mutation_Wrapper(complexed_pose, chain, position, ncaa, smiles, radius_relax = radius_relax,
                            trials = trials, mutationrelx = mutationrelx, mutation_dump = mutation_dump))

import math
from typing import Optional

from botorch.acquisition.monte_carlo import MCAcquisitionFunction
from botorch.models.model import Model
from botorch.sampling.base import MCSampler
from botorch.sampling.normal import SobolQMCNormalSampler
from botorch.utils import t_batch_mode_transform
from torch import Tensor


import math
from typing import Optional

from botorch.acquisition.monte_carlo import MCAcquisitionFunction
from botorch.models.model import Model
from botorch.sampling.base import MCSampler
from botorch.sampling.normal import SobolQMCNormalSampler
from botorch.utils import t_batch_mode_transform
from torch import Tensor


class Acquisition_Function:
    def __init__(
        self,
        model: Model,
        beta: 3, #control of uncertainty
        gamma: 3, #control of 3D Distance to Explored
        psi: 3, #control of 3D Distance to Binding
        nu: 300, #control of surface exposure. Scaled to be 0-100 similar to the distance balues
        obj_weights = None
    ):
        self.beta = beta
        self.gamma = gamma
        self.psi = psi
        self.nu = nu
        self.model = model
        self.obj_weights = torch.tensor(obj_weights)

    def forward(self, X, Explored_Distance, Binding_Distance, Surface_Exposures, model):

        with torch.no_grad():
            means = []
            stds = []

            for mod in self.model.models:
                posterior = mod.posterior(X)
                means.append(posterior.mean.squeeze(-1))
                stds.append(torch.sqrt(posterior.variance.squeeze(-1)))
            means = torch.stack(means, dim=-1)
            stds = torch.stack(stds, dim=-1)
            # Scalarize
            weighted_mean = (means * self.obj_weights).sum(dim=-1)
            weighted_std = (stds * self.obj_weights).sum(dim=-1)

            # Full acquisition value
            acquisition = weighted_mean -(self.beta * weighted_std  + self.gamma * Explored_Distance + self.psi * Binding_Distance+ self.nu * Surface_Exposures )
            return acquisition

    def __call__(self, X, Explored_Distance, Binding_Distance, Surface_Exposures,model):
        return self.forward(X, Explored_Distance, Binding_Distance, Surface_Exposures, model)

tkwargs = {  # Tkwargs is a dictionary contaning data about data type and data device
    "dtype": torch.double,
    "device": torch.device("cuda" if torch.cuda.is_available() else "cpu"),
}
SMOKE_TEST = os.environ.get("SMOKE_TEST")

complexed_pose = complexed
chain = target_chain_letter
ncaa = 'NAT'
smiles = 'tester'

from botorch.models import SingleTaskGP, ModelListGP
from gpytorch.mlls.sum_marginal_log_likelihood import SumMarginalLogLikelihood
from botorch.fit import fit_gpytorch_mll
from gpytorch.kernels import MaternKernel


iterations = 5


def bayesian_optimization(objective, binding_coordinates, target_range, iterations, complexed, target,
                          chain, ncaa, smiles, radius_relax=7, trials=3,
                          mutationrelx=True, mutation_dump=True, random_seed = None):
    np.random.seed(random_seed)
    possible_positions = np.array(target_range)
    np.random.shuffle(possible_positions)
    initial_positions = possible_positions[:5]

    print(f'Initial positions selected:{initial_positions}')
    inital_observations = []
    for position in initial_positions:
        print(f'Processing Position: {position}')
        inital_observations.append(objective(
            complexed, chain, [int(position)],
            ncaa, smiles, radius_relax=radius_relax,
            trials=trials, mutationrelx=mutationrelx,
            mutation_dump=mutation_dump
        ))
        print(f'Finished position: {position}')

    evaluated = torch.tensor(np.array(initial_positions, dtype=np.float64)).unsqueeze(-1)
    observations = torch.tensor(np.array(inital_observations, dtype=np.float64)).unsqueeze(-1)


    for i in range(iterations):
        models = []
        for i in range(observations.squeeze(-1).shape[-1]):
            obs = observations[:, i]
            mod = SingleTaskGP(evaluated, obs)
            mod.covar_module =MaternKernel(nu=.5)
            models.append(
                mod
            )

        model = ModelListGP(*models)
        mll = SumMarginalLogLikelihood(model.likelihood, model)

        fit_gpytorch_mll(mll)

        evaluated_flat = evaluated.squeeze().tolist()
        mask1 = [pos not in evaluated_flat for pos in target_range]
        unevaluated = torch.tensor(np.array(target_range)[mask1], dtype=torch.float64)

        evaluated_coordinates = get_coordiantes(target, evaluated)
        unevaluated_coordinates = get_coordiantes(target, unevaluated)

        acq_function = Acquisition_Function(model, beta=1.5, gamma=0.1, psi=0.1, nu=1, obj_weights=[1,1])

        with torch.no_grad():
            acq_values = acq_function(
                unevaluated.unsqueeze(1),
                Explored_Distance=distance_to_region(unevaluated_coordinates, evaluated_coordinates),
                Binding_Distance=distance_to_region(unevaluated_coordinates, binding_coordinates),
                Surface_Exposures=get_surface_exposures(target, unevaluated),
                model = model
            )
            
            

            nominated_point = acq_values.argmin()
            
            chosen_point = unevaluated[nominated_point].item()
            
            #chosen_point = np.random.choice(unevaluated)

            print(f'chosen_point: {chosen_point}')

            print(f'Next position to be evaluated: {chosen_point}')
            new_observation = objective(
                complexed, chain, [int(chosen_point)],
                ncaa, smiles, radius_relax=radius_relax,
                trials=trials, mutationrelx=mutationrelx,
                mutation_dump=mutation_dump
            )
            evaluated = torch.cat((evaluated, torch.tensor([[chosen_point]], dtype=torch.float64)))

            observations = torch.cat((observations, torch.tensor(new_observation, dtype = torch.float64).unsqueeze(-1).unsqueeze(0)))

            print(f"Iteration {i+1}: Best value = {observations.min().item()}, "
                  f"Acquisition = {acq_values[nominated_point].item()}")

    return evaluated, observations

import pandas as pd

all_results = []  # list to collect all trial results

for i in range(5):
    evaluated, observations = bayesian_optimization(
        objective,
        b_coordinates,
        target_range,
        15,
        complexed,
        target,
        chain,
        ncaa,
        smiles,
        radius_relax=7,
        trials=3,
        mutationrelx=True,
        mutation_dump=False,
        random_seed=i
    )

    evaluated = np.array(evaluated.squeeze(-1), dtype=int)
    observations = np.array(observations.squeeze(-1))

    # Create a DataFrame for this run and store run index
    print(evaluated.shape)
    print(observations[:,1].shape)
    df = pd.DataFrame({
        "Run": i,
        "Points Evaluated": evaluated,
        "Binding ddG": observations[:, 0],
        "Folding ddG": observations[:, 1]
    })
    
    print(evaluated.shape)
    print(observations.shape)

    all_results.append(df)

# Concatenate all runs into one DataFrame
final_df = pd.concat(all_results, ignore_index=True)

# Save one CSV with all runs
final_df.to_csv('08_20_M2_PI_UCBPI.csv', index = False)



